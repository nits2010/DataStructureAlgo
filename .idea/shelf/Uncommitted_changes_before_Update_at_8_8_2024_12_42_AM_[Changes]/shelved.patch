Index: src/main/java/DataStructureAlgo/Java/LeetCode2025/medium/NextGreaterElement/NextGreaterElementIII_556.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package DataStructureAlgo.Java.LeetCode2025.medium.NextGreaterElement;\r\n\r\nimport DataStructureAlgo.Java.nonleetcode.SuffixArray;\r\n\r\n/**\r\n * Author: Nitin Gupta\r\n * Date: 8/6/2024\r\n * Question Category: 556. Next Greater Element III @medium\r\n * Description: https://leetcode.com/problems/next-greater-element-iii/description/\r\n *\r\n * <p>\r\n * Given a positive integer n, find the smallest integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive integer exists, return -1.\r\n * <p>\r\n * Note that the returned integer should fit in 32-bit integer, if there is a valid answer but it does not fit in 32-bit integer, return -1.\r\n * <p>\r\n * <p>\r\n * <p>\r\n * Example 1:\r\n * <p>\r\n * Input: n = 12\r\n * Output: 21\r\n * Example 2:\r\n * <p>\r\n * Input: n = 21\r\n * Output: -1\r\n * <p>\r\n * <p>\r\n * Constraints:\r\n * <p>\r\n * 1 <= n <= 231 - 1\r\n * <p>\r\n * File reference\r\n * -----------\r\n * Duplicate {@link DataStructureAlgo.Java.LeetCode.nextGreaterElement.NextGreaterElementIII}\r\n * Similar {@link}\r\n * extension {@link }\r\n * <p>\r\n * Tags\r\n * -----\r\n *\r\n * @medium\r\n * @Math\r\n * @TwoPointers\r\n * @String\r\n * <p>\r\n *\r\n * Company Tags\r\n * -----\r\n * @Editorial <a href=\"https://leetcode.com/problems/next-greater-element-iii/solutions/326318/full-explanation-thought-process-java-0-ms-and-with-optimised-algo-not-require-sort\">...</a>\r\n */\r\npublic class NextGreaterElementIII_556 {\r\n\r\n    public static void main(String[] args) {\r\n        boolean test = true;\r\n        test &= test(12443322, 13222344);\r\n        test &= test(12222333,12223233);\r\n        test &= test(12,21);\r\n        test &= test(21,-1);\r\n        test &= test(218765,251678);\r\n        test &= test(1234,1243);\r\n        test &= test(4321,-1);\r\n        test &= test(534976,536479);\r\n        test &= test(1999999999,-1);\r\n        test &= test(230241,230412);\r\n\r\n        System.out.println((test) ? \"ALL TEST CASES PASSED\" : \"SOME TEST CASES FAILED\");\r\n\r\n\r\n    }\r\n\r\n    public static boolean test(int n, int expected) {\r\n       System.out.println(\"\\nn = \"+n + \"\\nexpected = \"+expected);\r\n\r\n        NextGreaterElementIII.Solution sol = new NextGreaterElementIII().new Solution();\r\n        int actual = sol.nextGreaterElement(n);\r\n        System.out.println(\"actual = \"+actual);\r\n        System.out.println(\"PASS = \" + (actual == expected));\r\n        return actual == expected;\r\n\r\n    }\r\n}\r\n\r\nclass NextGreaterElementIII {\r\n\r\n    class Solution {\r\n\r\n        /**\r\n         * https://stackoverflow.com/questions/9368205/given-a-number-find-the-next-higher-number-which-has-the-exact-same-set-of-digi\r\n         * 123456784987654321\r\n         * start with a number\r\n         * <p>\r\n         * 123456784 987654321\r\n         * ^the first place from the right where the left-digit is less than the right\r\n         * Digit \"x\" is 4\r\n         * <p>\r\n         * 123456784 987654321\r\n         * ^find the smallest digit larger than 4 to the right\r\n         * <p>\r\n         * 123456785 4 98764321\r\n         * ^place it to the left of 4\r\n         * <p>\r\n         * 123456785 4 12346789\r\n         * 123456785123446789\r\n         * ^sort the digits to the right of 5.  Since all of them except\r\n         * the '4' were already in descending order, all we need to do is\r\n         * reverse their order, and find the correct place for the '4'\r\n         *\r\n         * @param n\r\n         * @return\r\n         */\r\n        public int nextGreaterElement(int n) {\r\n\r\n            //if its single digit number, then it is maximum itself\r\n            if (n <= 9)\r\n                return -1;\r\n\r\n            //convert this number to individual numbers (single digit)\r\n            final int[] tokens = tokens(n);\r\n\r\n            //first find an index from the right side (towards the left) such that the current index value is less than the next index value.\r\n            int firstIndexSmallerThanNext = firstIndexSmallerThanNext(tokens);\r\n\r\n            if (firstIndexSmallerThanNext == -1)\r\n                return -1; // means all numbers are sorted in descending order\r\n\r\n            int secondIndexGreaterThanAndSmallestAmoung = secondIndexGreaterThanAndSmallestAmong(tokens, firstIndexSmallerThanNext);\r\n\r\n            swap(tokens, firstIndexSmallerThanNext, secondIndexGreaterThanAndSmallestAmoung);\r\n\r\n            reverse(tokens, firstIndexSmallerThanNext + 1, tokens.length - 1);\r\n\r\n            return buildInteger(tokens);\r\n\r\n\r\n        }\r\n\r\n        private int[] tokens(int n) {\r\n            //in any number of base 10, there will be at max log10(n) + 1 digits\r\n\r\n            int digits = (int) Math.floor(Math.log10(n) + 1);\r\n            int[] tokens = new int[digits];\r\n\r\n            int i = digits - 1;\r\n            while (i >= 0) {\r\n                tokens[i--] = n % 10;\r\n                n /= 10;\r\n\r\n            }\r\n            return tokens;\r\n        }\r\n\r\n\r\n        private int firstIndexSmallerThanNext(int[] tokens) {\r\n            int i = tokens.length - 1;\r\n            while (i > 0) {\r\n                if (tokens[i - 1] < tokens[i])\r\n                    return i - 1;\r\n                i--;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n\r\n        private int buildInteger(int[] tokens) {\r\n            int n = 0;\r\n            for (int i = 0; i < tokens.length; i++) {\r\n                n = n + (int) (tokens[i] * Math.pow(10, tokens.length - i - 1));\r\n            }\r\n            return n > 0 ? n : -1;\r\n        }\r\n\r\n        private void reverse(int[] tokens, int i, int j) {\r\n            while (i < j) {\r\n                swap(tokens, i++, j--);\r\n            }\r\n        }\r\n\r\n        private void swap(int[] tokens, int i, int j) {\r\n            int temp = tokens[i];\r\n            tokens[i] = tokens[j];\r\n            tokens[j] = temp;\r\n        }\r\n\r\n        private int secondIndexGreaterThanAndSmallestAmong(int[] tokens, int firstIndexSmallerThanNext) {\r\n            int i = tokens.length - 1;\r\n            while (i > firstIndexSmallerThanNext) {\r\n                if (tokens[i] > tokens[firstIndexSmallerThanNext])\r\n                    return i;\r\n                i--;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/DataStructureAlgo/Java/LeetCode2025/medium/NextGreaterElement/NextGreaterElementIII_556.java b/src/main/java/DataStructureAlgo/Java/LeetCode2025/medium/NextGreaterElement/NextGreaterElementIII_556.java
--- a/src/main/java/DataStructureAlgo/Java/LeetCode2025/medium/NextGreaterElement/NextGreaterElementIII_556.java	(revision 1e7693388bab4f439c387fe4e6358f34b504c841)
+++ b/src/main/java/DataStructureAlgo/Java/LeetCode2025/medium/NextGreaterElement/NextGreaterElementIII_556.java	(date 1722887194856)
@@ -37,7 +37,6 @@
  * <p>
  * Tags
  * -----
- *
  * @medium
  * @Math
  * @TwoPointers
Index: src/main/java/DataStructureAlgo/Java/LeetCode2025/medium/NextGreaterElement/NextGreaterElementI_496.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package DataStructureAlgo.Java.LeetCode2025.medium.NextGreaterElement;\r\n\r\nimport DataStructureAlgo.Java.helpers.GenericPrinter;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Stack;\r\n\r\n/**\r\n * Author: Nitin Gupta\r\n * Date: 8/5/2024\r\n * Question Category: 496. Next Greater Element I @easy\r\n * Description: https://leetcode.com/problems/next-greater-element-i/description/\r\n *\r\n * <p>\r\n *The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\r\n *\r\n * You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\r\n *\r\n * For each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\r\n *\r\n * Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.\r\n *\r\n *\r\n *\r\n * Example 1:\r\n *\r\n * Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\r\n * Output: [-1,3,-1]\r\n * Explanation: The next greater element for each value of nums1 is as follows:\r\n * - 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\r\n * - 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\r\n * - 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\r\n * Example 2:\r\n *\r\n * Input: nums1 = [2,4], nums2 = [1,2,3,4]\r\n * Output: [3,-1]\r\n * Explanation: The next greater element for each value of nums1 is as follows:\r\n * - 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\r\n * - 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.\r\n *\r\n *\r\n * Constraints:\r\n *\r\n * 1 <= nums1.length <= nums2.length <= 1000\r\n * 0 <= nums1[i], nums2[i] <= 104\r\n * All integers in nums1 and nums2 are unique.\r\n * All the integers of nums1 also appear in nums2.\r\n *\r\n *\r\n * Follow up: Could you find an O(nums1.length + nums2.length) solution?\r\n * <p>\r\n * File reference\r\n * -----------\r\n * Duplicate {@link DataStructureAlgo.Java.LeetCode.nextGreaterElement.NextGreaterElementII}\r\n * Similar {@link DataStructureAlgo.Java.LeetCode2025.medium.DailyTemperatures_739}\r\n * extension {@link }\r\n * <p>\r\n * Tags\r\n * -----\r\n *\r\n * @easy @medium @hard\r\n * <p>\r\n * Company Tags\r\n * -----\r\n */\r\npublic class NextGreaterElementI_496 {\r\n\r\n    public static void main(String[] args) {\r\n        boolean testResult = true;\r\n        testResult &= test(new int[]{4,1,2}, new int[]{1,3,4,2}, new int[]{-1,3,-1});\r\n        testResult &= test(new int[]{2,4}, new int[]{1,2,3,4}, new int[]{3,-1});\r\n        testResult &= test(new int[]{1,2,3,4,5}, new int[]{5,4,3,2,1}, new int[]{-1,-1,-1,-1,-1});\r\n        System.out.println((testResult ? \"All passed\" : \"Something failed\"));\r\n    }\r\n\r\n    private static boolean test(int[] nums1, int[] nums2, int[] expected) {\r\n        NextGreaterElementI.SolutionUsingStack solution = new NextGreaterElementI.SolutionUsingStack();\r\n        NextGreaterElementI.SolutionWithDS solutionWithDS = new NextGreaterElementI.SolutionWithDS();\r\n        System.out.println(\"\\nNum1:\" + Arrays.toString(nums1) + \"\\nNum2:\" + Arrays.toString(nums2) + \"\\nExpected:\" + Arrays.toString(expected));\r\n        int[] usingStacks = solution.nextGreaterElement(nums1, nums2);\r\n        int[] actualWithoutDS = solutionWithDS.nextGreaterElement(nums1, nums2);\r\n        System.out.println(\"usingStacks  :\" + Arrays.toString(usingStacks) + \"\\nactualWithoutDS:\" + Arrays.toString(actualWithoutDS));\r\n        boolean testResultUsingStacks =  GenericPrinter.equalsValues(expected, usingStacks);\r\n        boolean testResultNoDS =  GenericPrinter.equalsValues(expected, actualWithoutDS);\r\n        System.out.println(\"testResultUsingStacks :\" + (testResultUsingStacks ? \" Passed\" : \" Failed\"));\r\n        System.out.println(\"testResultNoDS :\" + (testResultNoDS ? \" Passed\" : \" Failed\"));\r\n        return testResultUsingStacks == testResultNoDS;\r\n    }\r\n}\r\n\r\nclass NextGreaterElementI{\r\n\r\n    /**\r\n     * Returns an array of integers that represent the next greater elements for each element in nums1.\r\n     * The next greater element for an element in nums1 is the first element in nums2 that is greater than the element.\r\n     * If there is no next greater element, -1 is returned.\r\n     *\r\n     * @param  nums1  an array of integers\r\n     * @param  nums2  an array of integers\r\n     * @return        an array of integers representing the next greater elements for each element in nums1\r\n     *\r\n     * @complexity Time/Space O(n) / O(n)\r\n     */\r\n   static class SolutionUsingStack {\r\n        public int[] nextGreaterElement(int[] nums1, int[] nums2) {\r\n            if(nums1 == null)\r\n                return nums1;\r\n\r\n            if(nums2 == null)\r\n                return null;\r\n\r\n            if(nums1.length > nums2.length)\r\n                return null ;\r\n\r\n            final Map<Integer,Integer> mapOfIndex = nextGreaterElementValuesForward(nums2);\r\n\r\n            final int [] output = new int[nums1.length];\r\n            for (int i=0; i<nums1.length; i++){\r\n                output[i] = mapOfIndex.getOrDefault(nums1[i],-1);\r\n            }\r\n\r\n            return output;\r\n\r\n        }\r\n\r\n        /**\r\n         * O(n)/O(n)\r\n         * This track the next greater element for each element in nums2 from backwards.\r\n         * @param nums2\r\n         * @return\r\n         *\r\n         * {@link DataStructureAlgo.Java.LeetCode2025.medium.DailyTemperatures.SolutionUsingStacks#dailyTemperatures}\r\n         */\r\n       private Map<Integer, Integer> nextGreaterElementValues( int[] nums2) {\r\n           final Map<Integer,Integer> nextGreaterElement = new HashMap<>();\r\n\r\n            int top = -1;\r\n            int []stack = new int[nums2.length];\r\n\r\n\r\n            //greater element of last element is always -1\r\n            nextGreaterElement.put(nums2[nums2.length-1], -1);\r\n\r\n            //push this element as it could be a greater element previous to its index.\r\n            stack[++top] = nums2[nums2.length-1];\r\n            int i = nums2.length-2;\r\n\r\n            //calculate greater element for all the previous index\r\n            while (i >=0){\r\n\r\n                //pop element from stack, until we have greater element present in it.\r\n                while(top>=0 && stack[top] <= nums2[i])\r\n                    top--;\r\n\r\n                //if there is no greater element in the stack, then output -1\r\n                if(top == -1) //stack is empty\r\n                    nextGreaterElement.put(nums2[i], -1);\r\n                else //if there is then that element is the greater element for current element\r\n                    nextGreaterElement.put(nums2[i], stack[top]);\r\n\r\n                //push this element as it could be a greater element previous to its index.\r\n                stack[++top] = nums2[i];\r\n                i--;\r\n            }\r\n            return nextGreaterElement;\r\n       }\r\n\r\n        /**\r\n         * {@link DataStructureAlgo.Java.LeetCode2025.medium.DailyTemperatures.SolutionUsingStacks#dailyTemperaturesForward}\r\n         * @param nums2\r\n         * @return\r\n         */\r\n        private Map<Integer, Integer> nextGreaterElementValuesForward( int[] nums2) {\r\n            final Map<Integer,Integer> nextGreaterElement = new HashMap<>();\r\n\r\n            int top = -1;\r\n            int []stack = new int[nums2.length];\r\n\r\n            int i = 0;\r\n            stack[++top] = nums2[i];\r\n\r\n            int j = i+1;\r\n            while (j < nums2.length){\r\n\r\n                while(top >=0 && stack[top] < nums2[j]){\r\n                    nextGreaterElement.put(stack[top], nums2[j]);\r\n                    top--;\r\n                }\r\n                stack[++top] = nums2[j];\r\n                j++;\r\n            }\r\n            while (top >=0 ){\r\n                nextGreaterElement.put(stack[top--], -1);\r\n            }\r\n\r\n            return nextGreaterElement;\r\n\r\n\r\n        }\r\n   }\r\n\r\n    static class SolutionWithDS {\r\n       //O(m*n)/O(1)\r\n        public int[] nextGreaterElement(int[] nums1, int[] nums2) {\r\n                final int [] indexCache = new int[10000];\r\n                for (int i=0; i<nums2.length; i++)\r\n                    indexCache[nums2[i]] =  i;\r\n\r\n                for (int i = 0; i<nums1.length; i++){\r\n                    nums1[i] = nextGreaterElement(indexCache[nums1[i]], nums2);\r\n                }\r\n                return nums1;\r\n        }\r\n\r\n        //O(n)/O(1)\r\n        private int nextGreaterElement(int index, int []nums){\r\n            for (int i=index+1; i<nums.length; i++){\r\n                if (nums[i] > nums[index])\r\n                    return nums[i];\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/DataStructureAlgo/Java/LeetCode2025/medium/NextGreaterElement/NextGreaterElementI_496.java b/src/main/java/DataStructureAlgo/Java/LeetCode2025/medium/NextGreaterElement/NextGreaterElementI_496.java
--- a/src/main/java/DataStructureAlgo/Java/LeetCode2025/medium/NextGreaterElement/NextGreaterElementI_496.java	(revision 1e7693388bab4f439c387fe4e6358f34b504c841)
+++ b/src/main/java/DataStructureAlgo/Java/LeetCode2025/medium/NextGreaterElement/NextGreaterElementI_496.java	(date 1722887122401)
@@ -59,8 +59,13 @@
  * <p>
  * Tags
  * -----
+ * @easy
+ * @Array
+ * @HashTable
+ * @Stack
+ * @MonotonicStack
  *
- * @easy @medium @hard
+ *
  * <p>
  * Company Tags
  * -----
