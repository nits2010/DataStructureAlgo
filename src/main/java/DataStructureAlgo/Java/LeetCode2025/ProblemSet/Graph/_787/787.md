1️⃣ Bellman-Ford:

“Relax all edges k+1 times → each round = paths using ≤ i edges → naturally enforces stops constraint.”

2️⃣ BFS (level-by-level):

“Explore all nodes per edge-level → each level = edges used → track min cost per node → prune stops > k.”

3️⃣ Dijkstra (min-heap):

“Heap stores (cost, stops, node) → always expand lowest cost → allow multiple entries per node → prune stops > k.”

| Approach            | Intuition                                            | Time            | Space  | Key Notes                                                                                       |
| ------------------- | ---------------------------------------------------- | --------------- | ------ | ----------------------------------------------------------------------------------------------- |
| Bellman-Ford        | Relax edges layer-by-layer k+1 times                 | O(k*E)          | O(n)   | Clean, simple, naturally handles ≤k stops, copy array per iteration avoids over-relaxation      |
| BFS                 | Level-by-level exploration, each level = #edges used | O(E*K)          | O(E*K) | Tracks min cost per node, stops prune invalid paths, intuitive for level-based reasoning        |
| Dijkstra (min-heap) | Heap stores (cost, stops, node)                      | O(E*K*log(n*K)) | O(n*K) | Correct, but more bookkeeping, prune entries with stopsUsed > k, multiple heap entries per node |


