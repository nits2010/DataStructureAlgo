# Longest Square Streak

## Intuition-UsingMapSort
The goal is to find the longest streak of numbers in the array where each number is the square of the previous number. 
By sorting the array and using a set to track the numbers, we can efficiently determine the streaks.

## Approach
1. **Sort the Array**: Sorting helps in processing the numbers in ascending order, which simplifies the streak calculation.
2. **Populate the Set**: Add all numbers to a set for O(1) average-time complexity lookups.
3. **Calculate Streaks**:
    - Iterate through each number in the sorted array.
    - For each number, use a helper function `getMaxStreakBS` to calculate the streak starting from that number.
    - Update the maximum streak found.
4. **Helper Function `getMaxStreakBS`**:
    - Initialize the streak count.
    - Continuously check if the current number's square exists in the set.
    - If it does, increment the streak count, remove the number from the set to avoid reprocessing, and update the current number to its square.
    - Return the streak count.

## Complexity
- **Time Complexity**:
    - Sorting the array: O(n * log n)
    - Populating the set: O(n)
    - Main loop with `getMaxStreakBS`: O(n) * O(log n) = O(n * log n)
    - Overall: **O(n * log n)**
- **Space Complexity**:
    - The set stores all the numbers: O(n)
    - Additional space for variables and function call stack:  O(1)
    - Overall: ** O(n)**


## Intuition-UsingMapSortBinarySearch
This is similar to above idea, instead of pushing element in set and then remove post finding it, we will use binary search to find the element in the array.
if found, then push in set to avoid reprocessing.


## Intuition-Using Map Without Sort/UsingMapWithoutSortImproved
The one thing is to note here that if the square number exists then its must be in nums only. But finding it takes either `O(n)` or `O(log n)` time. 
Which can be avoided if we use a map to store the numbers. Additionally, it could possible that we have reached same pre-computed element again, in such case, we should not
re-compute its streak, rather utilize the previous computed streak.

## Approach
1. **Initialize Data Structures**:
    - A HashMap `set` to map each number to its index for O(1) average-time complexity lookups.

2. **Populate the HashMap**:
    - Iterate through the `nums` array and populate the `set` with each number and its index/ or its max streak which is `0` initially.

3. **Calculate Streaks**:
    - Iterate through each number in the `nums` array.
    - For each number, calculate the streak starting from that number using a while loop.
    - In the while loop, check if the current number's square exists in the `set`.
    - If it does, increment the streak count, update the current number to its square, and continue.
    - If the current number has already been processed (i.e., its streak is stored in `set`), add that streak to the current streak and break the loop.
    - Update the maximum streak found.

4. **Return the Result**:
    - If the maximum streak is 1, return -1 (indicating no valid streak found).
    - Otherwise, return the maximum streak.

## Complexity
- **Time Complexity**:
    - Populating the HashMap: `O(n)`
    - Main loop with while loop: `O(n * O(10^5) = O(n)` the inner loop will execute max 10^5 times.  
    - Overall: **\(O(n \log n)\)**

- **Space Complexity**:
    - Overall: `O(n)`
  