# [2516. Take K of Each Character From Left and Right](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/description/)

# Overview

We are given a string `s` containing only the characters 'a', 'b', and 'c', along with a non-negative integer `k`. The goal is to calculate the minimum number of minutes needed to ensure at least `k` instances of each character remain in the string. The removal process allows us to eliminate one character per minute, and we can only remove characters from either the left or right ends of the string. If it is not possible to retain at least `k` occurrences of each character, the function should return `-1`.

## Approach 1: Brute force
- Try all combination of (i,j) where i denotes take from left [0...i] and j denotes take from right [j...n-1] 

```
For every possible value of i in [0..n]:
    For every possible value of j in [0..n-i]:
        count a,b,c counts for both 0..i and n-j ...n
        if condition satisfy, keep 


```

## Appraoch 2: Sliding Window
- Instead of deciding what to take, what if we decide what to leave in the middle?

```
What must be true about the middle substring if we are taking at least k of each character from the ends?
ans = middle should have total - k

```
- Let total count of each character in the whole string be total[c].
- If we must take at least k of each character from the ends

```
How many of each character are we allowed to leave inside the middle substring at most? 
ans = total[c] - k
```
- We can leave at most total[c] - k of each character in the middle.

```
- If we maximize the length of such a valid middle substring, what happens to the number of characters we take from the ends?
ans = that will be minimized
```

- So the problem becomes:

üëâ Find the longest substring where
for every character c:

```
count_in_window[c] ‚â§ total[c] ‚àí k
```

### 1Ô∏è‚É£ One-line Intuition

Instead of choosing what to take from ends, find the longest middle substring that keeps each character 
```
count ‚â§ total[c] - k.
```

2Ô∏è‚É£ Step-by-step Logic

- Count total frequency of 'a', 'b', 'c'.

- If any total < k ‚Üí return -1.

- Let allowed[c] = total[c] ‚àí k aka `limits`

- Use sliding window to find longest substring where
```
window_count[c] ‚â§ allowed[c] for all chars.
```

- Answer = N - max_window_length.