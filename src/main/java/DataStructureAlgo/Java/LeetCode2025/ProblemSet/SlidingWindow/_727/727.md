
# Minimum Window Subsequence — Full Derivation (Greedy + DP)

> Problem:
> Given strings `s1` and `s2`, return the minimum contiguous substring of `s1`
> such that `s2` is a subsequence of that substring.
> If multiple answers exist, return the left-most one.

This write-up intentionally **derives the solution from first principles**,
exactly the way you would reason in an interview.

---

## 0. What problem is this REALLY?

This is **NOT** Minimum Window Substring (LC 76).

This is:

> **Minimum Window Subsequence (LC 727)**

### Why this matters
| Problem | Order matters? |
|------|----------------|
| Min Window Substring | ❌ No |
| **Min Window Subsequence** | ✅ Yes |

The moment **order matters**, frequency maps and classic sliding window break.

---

## 1. Restating the problem in plain English

We want:
- A **contiguous substring** of `s1`
- Inside it, `s2` must appear **in order**
- Window length must be **minimum**
- If tie → **left-most start**

Example:
```
s1 = "abcdebdde"
s2 = "bde"
```
Valid windows:
- "bcde"
- "bdde"

Both length = 4 → pick `"bcde"`

---

## 2. Why Sliding Window fails

Sliding window works when:
- Order does NOT matter
- We only care about counts

Here:
```
window = "deb"
s2 = "bde"
```
Counts match, but order does not → ❌ invalid

So sliding window + hashmap is **fundamentally wrong**.

---

## 3. Core Insight

To validate a window:
- Characters of `s2` must be matched **sequentially**
- We must know **where the window started**, not just that it exists

This immediately suggests **Dynamic Programming**.

---

## 4. DP — Deriving the state (the most important step)

We ask:

> If a subsequence match ends at position `i` in `s1`,
> where did that window start?

So define:

```
dp[i][j] = starting index in s1
           of a window that ends at i
           and matches s2[0..j] as a subsequence
```

If impossible → `-1`.

This DP tracks **earliest possible start**, not just feasibility.

---

## 5. Base Case (j = 0)

Matching only the first character of `s2`.

If:
```
s1[i] == s2[0]
```
Then:
```
dp[i][0] = i
```

Otherwise:
```
dp[i][0] = dp[i-1][0]
```

Once the first character is matched,
it stays matched for all future indices unless replaced.

---

## 6. DP Transition

For `i > 0` and `j > 0`:

```
if s1[i] == s2[j]:
    dp[i][j] = dp[i-1][j-1]   # extend subsequence
else:
    dp[i][j] = dp[i-1][j]     # ignore s1[i]
```

This mirrors subsequence logic exactly.

---

## 7. Extracting the answer from DP

Look at the last column `j = m-1`.

For every `i` where:
```
dp[i][m-1] != -1
```
We have a valid window:
```
length = i - dp[i][m-1] + 1
```

Pick the minimum length,
tie → left-most start.

---


---

## 9. Time & Space Complexity (DP)

- Time: **O(n · m)**
- Space: **O(n · m)**

Correct, but memory-heavy.

---

## 10. Greedy Optimization — Compressing DP

Observation:
- DP is only used to:
  1. Find an end where `s2` completes
  2. Reconstruct the earliest start

We can do both **on the fly**.

---

## 11. Greedy Strategy (Two-Phase Scan)

### Phase 1: Forward Scan
- Walk `s1`
- Try to match `s2` sequentially
- When all of `s2` is matched → we found a valid end

### Phase 2: Backward Shrink
- From the end, move backwards
- Match `s2` in reverse
- Shrink window to minimum size

Repeat to find all candidate windows.

---

## 12. Why resetting `i = start + 1` is required

To allow **overlapping windows**.

Example:
```
s1 = abcdebdde
```
If we jump to `end + 1`, we miss `"bdde"`.

Resetting ensures correctness.

---


---

## 14. DP vs Greedy (Mental Model)

| DP | Greedy |
|--|--|
| Store start index | Reconstruct start |
| Explicit correctness | Implicit correctness |
| O(n·m) space | O(1) space |

Greedy is **DP without storing the table**.

---

## 15. Final Takeaways

- This is **not** a sliding window problem
- Order constraint forces subsequence logic
- DP gives correctness proof
- Greedy is the optimized form
- Constraints make O(n·m) acceptable

---

End of derivation.
