# Cracking the Graph Interview: A Comprehensive Guide

Graphs are often the "final boss" of coding interviews. They aren't inherently harder than trees; they just have fewer rules. While a tree is a disciplined hierarchy, a graph is a free-for-all of relationships.

---

## 1. The Basics: Vertices, Edges, and Logic

At its core, a graph is a collection of **Nodes (Vertices)** connected by **Edges**.

### Representations

* **Adjacency List:** An array of lists. Space-efficient $O(V + E)$. The go-to for most interview problems.
* **Adjacency Matrix:** A 2D grid. $O(V^2)$ space. Best for dense graphs or checking if an edge exists in $O(1)$.

---

## 2. Graph Flavors: Directed, Undirected, DAG, and Cycles

Understanding the "rules of the road" for your graph is half the battle.

* **Undirected:** Edges are two-way streets (A <-> B).
* **Directed (Digraph):** Edges have a specific direction (A -> B).
* **Weighted:** Edges have "costs" (like distance or toll).
* **Cyclic:** You can start at one node and follow a path back to it.
* **DAG (Directed Acyclic Graph):** A directed graph with **no cycles**. This is the darling of interviewers because it allows for **Topological Sorting**.

---

## 3. Cycle Detection: Finding the Loop

If you don't find the cycle, the cycle (infinite loop) will find your CPU.

### Undirected Graph

* **The Algorithm:** **DFS with a Parent Pointer.**
* **Logic:** While traversing, if you encounter a neighbor that is already visited and is **not** the parent of the current node, you've found a cycle.
* **Alternative:** **Union-Find.** If you try to union two nodes already in the same set, there's a cycle.

### Directed Graph

* **The Algorithm:** **DFS with a Recursion Stack.**
* **Logic:** Keep track of nodes currently in the "active" recursion path. If you hit a node that is already in the current stack, it’s a "back-edge" (cycle).
* **Alternative:** **Kahn’s Algorithm (BFS).** If the number of nodes processed in a topological sort is less than V, a cycle exists.

---

## 4. Shortest Paths: Getting from A to B

The "best" algorithm depends entirely on the edge weights.

| Scenario | Algorithm | The "Vibe" |
| --- | --- | --- |
| **Unweighted** | **BFS** | Level-order traversal. First time you hit the target, it's the shortest path. |
| **Weighted (Non-negative)** | **Dijkstra** | Greedy. Uses a Priority Queue to always expand the "cheapest" known node. |
| **Weighted (Negative edges)** | **Bellman-Ford** | Relaxes all edges $V-1$ times. Can detect negative cycles. |
| **All-Pairs Shortest Path** | **Floyd-Warshall** | Dynamic Programming. Best for small graphs where you need distances between *all* pairs. |

---

## 5. Minimum Spanning Tree (MST)

An MST is a subset of edges that connects all vertices with the minimum total edge weight and no cycles.

### **Kruskal’s Algorithm:**
* **Logic:** Sort all edges by weight. Use **Union-Find** to add the smallest edges one by one, skipping any that create a cycle.
* **Best for:** Sparse graphs (fewer edges).


### **Prim’s Algorithm:**
* **Logic:** Start from a node and grow the tree greedily by picking the cheapest edge that connects a "tree" node to a "non-tree" node.
* **Best for:** Dense graphs.



---

## 6. Strongly Connected Components (SCC)

Only applicable to **Directed Graphs**. An SCC is a sub-portion of a graph where every node is reachable from every other node in that sub-portion.

### **Kosaraju’s Algorithm:**
1. Perform DFS to get finish times (using a stack).
2. **Transpose** the graph (reverse all edges).
3. Perform DFS on the transposed graph in the order of the stack.


### **Tarjan’s Algorithm:**
* Uses a single DFS pass and "Low-link" values to identify nodes that can reach their ancestors.



---

## 7. The "Interview Mental Model"

When you see a graph problem, run this mental checklist:

1. **Is it a graph?** (Sometimes it's hidden as a matrix or a dependency list).
2. **Directed or Undirected?** (Crucial for cycle detection logic).
3. **Weighted or Unweighted?** (Unweighted = BFS; Weighted = Dijkstra).
4. **Are there dependencies?** (Think Topological Sort/DAG).
5. **Connectivity?** (Think BFS/DFS for islands, or SCC for directed loops).

> **Pro Tip:** If you're stuck, try **BFS/DFS** first. 80% of interview problems are just clever applications of basic traversal.

